
use log::{trace, debug, info};
use std::ops::{Index, IndexMut, Range};
use std::fmt;
use std::ops;

type Address = u16;
type Byte = u8;

pub struct MemorySpace([u8; MEMORY_END as usize]);

impl MemorySpace {
    pub fn new() -> MemorySpace {
        let mut memory = [0; MEMORY_END as usize];
        memory[0..BOOT_ROM.len()].copy_from_slice( &BOOT_ROM );
        MemorySpace(memory)
    }

//    pub fn find_memory_area(&self, address: Address) -> MemoryArea {
//
//        if BOOTROM_RANGE.contains(&address) { MemoryArea::BootRom }
//        if GameRomBank0_RANGE.contains(&address) { MemoryArea::BootRom }
//        if GameRomBankN_RANGE.contains(&address) { MemoryArea::BootRom }
//        if TileRam_RANGE.contains(&address) { MemoryArea::BootRom }
//        if BackgroundMap_RANGE.contains(&address) { MemoryArea::BootRom }
//        if CartridgeRam_RANGE.contains(&address) { MemoryArea::BootRom }
//        if WorkingRam_RANGE.contains(&address) { MemoryArea::BootRom }
//        if EchoRam_RANGE.contains(&address) { MemoryArea::BootRom }
//        if ObjectAttributeMemory_RANGE.contains(&address) { MemoryArea::BootRom }
//        if Unmapped_RANGE.contains(&address) { MemoryArea::BootRom }
//        if IORegisters_RANGE.contains(&address) { MemoryArea::BootRom }
//        if HighRam_RANGE.contains(&address) { MemoryArea::BootRom }
//        if InterruptEnabledRegiste_RANGE.contains(&address) { MemoryArea::BootRom }
//
//        panic!("Address {:#X} does not belong to memory space, cannot map to area", address)
//    }
}

//pub enum MemoryArea {
//    BootRom,
//    GameRomBank0,
//    GameRomBankN,
//    TileRam,
//    BackgroundMap,
//    CartridgeRam,
//    WorkingRam,
//    EchoRam,
//    ObjectAttributeMemory,
//    Unmapped,
//    IORegisters,
//    HighRam,
//    InterruptEnabledRegister
//}
//
//const BOOTROM_RANGE: Range<Address> = (MEMORY_START..0x00FF);
//const GameRomBank0_RANGE: Range<Address> = (MEMORY_START..0x3FFF);
//const GameRomBankN_RANGE: Range<Address> = (0x4000..0x7FFF);
//const TileRam_RANGE: Range<Address> =       (0x8000..0x97FF);
//const BackgroundMap_RANGE: Range<Address> = (0x9800..0x9FFF);
//const CartridgeRam_RANGE: Range<Address> = (0xA000..0xBFFF);
//const WorkingRam_RANGE: Range<Address> = (0x8000..0x00FF);
//const EchoRam_RANGE: Range<Address> =     (0x8000..0x00FF);
//const ObjectAttributeMemory_RANGE: Range<Address> = (0x8000..0x00FF);
//const Unmapped_RANGE: Range<Address> = (0x8000..0x00FF);
//const IORegisters_RANGE: Range<Address> = (0x8000..0x00FF);
//const HighRam_RANGE: Range<Address> = (0x8000..0x00FF);
//const InterruptEnabledRegiste_RANGE: Range<Address> = (0x8000..0x00FF);

const MEMORY_START: Address = 0x0000;
const MEMORY_END: Address   = 0xFFFF;

impl Index<Address> for MemorySpace {
    type Output = Byte;

    fn index(&self, address: Address) -> &Self::Output {
        if address < MEMORY_START || address > MEMORY_END {
            panic!("Invalid unsafe memory access to {:#X}", address);
        } else {
            trace!("Reading memory address {:#X}", address);
            &self.0[ address as usize ]
        }
    }
}


impl IndexMut<Address> for MemorySpace {

    fn index_mut(&mut self, address: Address) -> &mut Self::Output {
        if address < MEMORY_START || address > MEMORY_END {
            panic!("Invalid unsafe memory write to {:#X}", address);
        } else {
            trace!("Writing memory address {:#X}", address);
            &mut self.0[ address as usize ]
        }
    }
}

impl std::fmt::Debug for MemorySpace {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Memory({:?} bytes)", self.0.len())
    }
}

const BOOT_ROM: [Byte; 256] = [
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50,
];